/* =============================================================================
 * Pico Miner -- ARM Bare-Metal Driver (Zynq PS)
 *
 * Description:
 *   This program runs on the ARM Cortex-A9 processor (PS) of the Zynq SoC.
 *   It communicates with the Pico Miner HLS IP instantiated in the
 *   programmable logic (PL) via AXI-Lite registers.
 *
 *   The driver:
 *   1. Writes block header data and mining parameters to the HLS IP
 *   2. Starts the hardware mining operation
 *   3. Waits for completion (polls ap_done)
 *   4. Reads back results (nonce, hash, status)
 *   5. Compares HW results with a SW golden model for verification
 *
 * Target: Xilinx Zynq-7020 (ZedBoard or similar)
 * Tool: Xilinx SDK 2019.1
 *
 * Note: The XPico_miner_* driver functions are AUTO-GENERATED by Vivado HLS
 *       when the IP is exported. The header "xpico_miner.h" is created
 *       automatically from the HLS interface pragmas.
 *
 * Author: Pico Miner Project
 * Date: 2026
 * =============================================================================
 */

#include <stdio.h>
#include "platform.h"
#include "xparameters.h"
#include "xpico_miner.h"  /* Auto-generated by Vivado HLS export */

/* =============================================================================
 * PicoHash Constants (must match pico_miner.h)
 * =============================================================================
 */
#define BLOCK_HEADER_SIZE  4
#define HASH_SEED          0x5A3CF1E7u
#define FNV_PRIME          0x01000193u
#define MURMUR_M           0x5BD1E995u
#define MINING_FOUND       1
#define MINING_NOT_FOUND   0

/* =============================================================================
 * Software Golden Model (identical to HLS implementation)
 *
 * Used to verify that the hardware IP produces correct results.
 * =============================================================================
 */
static unsigned int pico_hash_sw(unsigned int data[BLOCK_HEADER_SIZE],
                                 unsigned int nonce)
{
    unsigned int h = HASH_SEED;
    int i;

    for (i = 0; i < BLOCK_HEADER_SIZE; i++) {
        h = h ^ data[i];
        h = h * FNV_PRIME;
        h = h ^ (h >> 16);
    }

    h = h ^ nonce;
    h = h * MURMUR_M;
    h = h ^ (h >> 13);
    h = h * MURMUR_M;
    h = h ^ (h >> 15);

    return h;
}

static void pico_miner_sw(unsigned int block_header[BLOCK_HEADER_SIZE],
                           unsigned int difficulty_target,
                           unsigned int nonce_start,
                           unsigned int nonce_end,
                           unsigned int *found_nonce,
                           unsigned int *found_hash,
                           unsigned int *status)
{
    unsigned int nonce, hash_result;

    *found_nonce = 0;
    *found_hash  = 0xFFFFFFFF;
    *status      = MINING_NOT_FOUND;

    for (nonce = nonce_start; nonce < nonce_end; nonce++) {
        hash_result = pico_hash_sw(block_header, nonce);
        if (hash_result < difficulty_target) {
            *found_nonce = nonce;
            *found_hash  = hash_result;
            *status      = MINING_FOUND;
            break;
        }
    }
}

/* =============================================================================
 * Main Program
 * =============================================================================
 */
int main(void)
{
    /* --- HLS IP instance and configuration --- */
    XPico_miner          Pico_miner_inst;
    XPico_miner_Config  *Pico_miner_cfg_ptr;
    int hw_status_init;

    /* --- Mining parameters --- */
    unsigned int block_header[BLOCK_HEADER_SIZE] = {
        0xDEADBEEF,  /* Previous block hash (simplified) */
        0xCAFEBABE,  /* Transaction root (simplified) */
        0x12345678,  /* Timestamp */
        0xABCD0001   /* Block version */
    };
    unsigned int difficulty_target = 0x10000000;  /* Easy difficulty */
    unsigned int nonce_start       = 0x00000000;
    unsigned int nonce_end         = 0x00100000;  /* ~1M nonces */

    /* --- Result variables --- */
    unsigned int hw_nonce, hw_hash, hw_mining_status;
    unsigned int sw_nonce, sw_hash, sw_mining_status;

    /* =========================================================================
     * Platform initialization
     * ========================================================================= */
    init_platform();

    printf("\r\n");
    printf("############################################################\r\n");
    printf("#                                                          #\r\n");
    printf("#           PICO MINER -- FPGA PoW Accelerator             #\r\n");
    printf("#            ARM Driver (Zynq PS) + HLS IP (PL)            #\r\n");
    printf("#                                                          #\r\n");
    printf("############################################################\r\n");
    printf("\r\n");

    /* =========================================================================
     * Step 1: Initialize HLS IP
     * ========================================================================= */
    printf("[INIT] Looking up Pico Miner IP configuration...\r\n");
    Pico_miner_cfg_ptr = XPico_miner_LookupConfig(XPAR_PICO_MINER_0_DEVICE_ID);

    if (!Pico_miner_cfg_ptr) {
        printf("[ERROR] Could not find Pico Miner IP configuration!\r\n");
        printf("[ERROR] Check that the IP is instantiated in the block design.\r\n");
        return XST_FAILURE;
    }

    hw_status_init = XPico_miner_CfgInitialize(&Pico_miner_inst,
                                                 Pico_miner_cfg_ptr);
    if (hw_status_init != XST_SUCCESS) {
        printf("[ERROR] Failed to initialize Pico Miner IP (status=%d)\r\n",
               hw_status_init);
        return XST_FAILURE;
    }
    printf("[INIT] Pico Miner IP initialized successfully.\r\n\r\n");

    /* =========================================================================
     * Step 2: Write mining parameters to HLS IP via AXI-Lite
     * ========================================================================= */
    printf("[CONFIG] Block header: [0x%08X, 0x%08X, 0x%08X, 0x%08X]\r\n",
           block_header[0], block_header[1],
           block_header[2], block_header[3]);
    printf("[CONFIG] Difficulty target: 0x%08X\r\n", difficulty_target);
    printf("[CONFIG] Nonce range: [0x%08X, 0x%08X)\r\n",
           nonce_start, nonce_end);
    printf("\r\n");

    /* Write block header array to IP */
    XPico_miner_Write_block_header_Words(&Pico_miner_inst, 0,
                                          (int *)block_header,
                                          BLOCK_HEADER_SIZE);

    /* Write scalar parameters */
    XPico_miner_Set_difficulty_target(&Pico_miner_inst, difficulty_target);
    XPico_miner_Set_nonce_start(&Pico_miner_inst, nonce_start);
    XPico_miner_Set_nonce_end(&Pico_miner_inst, nonce_end);

    /* =========================================================================
     * Step 3: Start hardware mining and wait for completion
     * ========================================================================= */
    printf("[MINING] Starting hardware miner...\r\n");
    XPico_miner_Start(&Pico_miner_inst);

    /* Poll ap_done flag */
    printf("[MINING] Waiting for completion (polling ap_done)...\r\n");
    while (!XPico_miner_IsDone(&Pico_miner_inst)) {
        /* Busy wait -- in a real system you could use interrupts */
    }
    printf("[MINING] Hardware miner finished!\r\n\r\n");

    /* =========================================================================
     * Step 4: Read results from HLS IP
     * ========================================================================= */
    hw_nonce         = XPico_miner_Get_found_nonce(&Pico_miner_inst);
    hw_hash          = XPico_miner_Get_found_hash(&Pico_miner_inst);
    hw_mining_status = XPico_miner_Get_status(&Pico_miner_inst);

    printf("[HW RESULT] Status: %s\r\n",
           (hw_mining_status == MINING_FOUND) ? "FOUND" : "NOT FOUND");
    if (hw_mining_status == MINING_FOUND) {
        printf("[HW RESULT] Winning nonce: 0x%08X\r\n", hw_nonce);
        printf("[HW RESULT] Hash value:    0x%08X\r\n", hw_hash);
        printf("[HW RESULT] Below target?  %s\r\n",
               (hw_hash < difficulty_target) ? "YES" : "NO (ERROR!)");
    }
    printf("\r\n");

    /* =========================================================================
     * Step 5: Run software golden model and compare
     * ========================================================================= */
    printf("[SW] Running software reference miner for verification...\r\n");
    pico_miner_sw(block_header, difficulty_target, nonce_start, nonce_end,
                  &sw_nonce, &sw_hash, &sw_mining_status);

    if (sw_mining_status == MINING_FOUND) {
        printf("[SW RESULT] Winning nonce: 0x%08X\r\n", sw_nonce);
        printf("[SW RESULT] Hash value:    0x%08X\r\n", sw_hash);
    } else {
        printf("[SW RESULT] Not found in range.\r\n");
    }
    printf("\r\n");

    /* =========================================================================
     * Step 6: Compare SW vs HW results
     * ========================================================================= */
    printf("============================================================\r\n");
    printf("           SW vs HW Comparison\r\n");
    printf("============================================================\r\n");
    printf("  Status:  SW=%u  HW=%u  %s\r\n",
           sw_mining_status, hw_mining_status,
           (sw_mining_status == hw_mining_status) ? "[OK]" : "[MISMATCH]");
    printf("  Nonce:   SW=0x%08X  HW=0x%08X  %s\r\n",
           sw_nonce, hw_nonce,
           (sw_nonce == hw_nonce) ? "[OK]" : "[MISMATCH]");
    printf("  Hash:    SW=0x%08X  HW=0x%08X  %s\r\n",
           sw_hash, hw_hash,
           (sw_hash == hw_hash) ? "[OK]" : "[MISMATCH]");
    printf("============================================================\r\n");

    if (sw_mining_status == hw_mining_status &&
        sw_nonce == hw_nonce &&
        sw_hash  == hw_hash) {
        printf("\r\n  >>> ALL RESULTS MATCH -- VERIFICATION PASSED <<<\r\n\r\n");
    } else {
        printf("\r\n  >>> MISMATCH DETECTED -- VERIFICATION FAILED <<<\r\n\r\n");
    }

    /* =========================================================================
     * Alternative: Low-level register access (for reference/debugging)
     *
     * The HLS-generated AXI-Lite register map can be found in the
     * auto-generated header file after IP export. Typical layout:
     *
     *   0x00       : Control register (ap_start, ap_done, ap_idle, ap_ready)
     *   0x04       : Global Interrupt Enable
     *   0x08       : IP Interrupt Enable Register
     *   0x0C       : IP Interrupt Status Register
     *   0x40-0x4F  : block_header[0..3] (4 x 32-bit words)
     *   0x50       : difficulty_target
     *   0x58       : nonce_start
     *   0x60       : nonce_end
     *   0x68       : found_nonce (read-only)
     *   0x70       : found_hash  (read-only)
     *   0x78       : status      (read-only)
     *
     * Example low-level access:
     *   XPico_miner_WriteReg(base_addr, 0x40, block_header[0]);
     *   XPico_miner_WriteReg(base_addr, 0x00, 0x01);  // ap_start
     *   while (!(XPico_miner_ReadReg(base_addr, 0x00) & 0x02)); // ap_done
     *   result = XPico_miner_ReadReg(base_addr, 0x68);
     * ========================================================================= */

    cleanup_platform();
    return 0;
}
